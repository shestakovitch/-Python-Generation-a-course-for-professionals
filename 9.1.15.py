"""Функция zip_longest()
Как уже известно, функция zip() объединяет элементы различных последовательностей. Особенностью функции является то,
что при передаче последовательностей различной длины элементы последовательности большей длины будут отброшены.

Реализуйте функцию zip_longest(), которая принимает переменное количество позиционных аргументов, каждый из которых
является списком, и один необязательный именованный аргумент fill, имеющий значение по умолчанию None.

Функция должна объединять элементы переданных последовательностей в кортежи, аналогично функции zip(), и возвращать в
виде списка, но если последовательности имеют различную длину, недостающие элементы последовательностей меньшей длины
должны принимать значение fill.

Примечание 1. Рассмотрим первый тест со следующим вызовом:

zip_longest([1, 2, 3, 4, 5], ['a', 'b', 'c'], fill='_')
Первый список имеет длину
5
5, второй —
3
3, то есть элементам 4 и 5 из первого списка нет пар из второго списка. В таком случае, функция должна сопоставить им
значение fill, равное '_'. Итак, результатом работы функции будет список:

[(1, 'a'), (2, 'b'), (3, 'c'), (4, '_'), (5, '_')]
Примечание 2. В тестирующую систему сдайте программу, содержащую только необходимую функцию zip_longest(), но не код,
вызывающий ее. """


def zip_longest(*args, fill=None):
    max_len = max([len(i) for i in args])
    lst_1 = list(map(lambda x: x + [fill] * (max_len - len(x)), args))
    return [i for i in zip(*lst_1)]